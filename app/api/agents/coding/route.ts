import { NextRequest, NextResponse } from 'next/server'
import { OpenAI } from 'openai'
import * as cheerio from 'cheerio'

const openai = new OpenAI({
  apiKey: process.env.GROQ_API_KEY,
  baseURL: 'https://api.groq.com/openai/v1',
})

interface LeetCodeProblem {
  title: string
  difficulty: string
  description: string
  examples: Array<{
    input: string
    output: string
    explanation?: string
  }>
}

async function scrapeLeetCodeProblem(url: string): Promise<LeetCodeProblem> {
  try {
    // For demo purposes, we'll simulate scraping with a mock response
    // In production, you'd use Puppeteer or similar to scrape the actual page
    
    // Extract problem slug from URL
    const match = url.match(/problems\/([^\/]+)/)
    const slug = match ? match[1] : 'two-sum'
    
    // Mock data based on common problems
    const mockProblems: Record<string, LeetCodeProblem> = {
      'two-sum': {
        title: 'Two Sum',
        difficulty: 'Easy',
        description: `Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.

You may assume that each input would have exactly one solution, and you may not use the same element twice.

You can return the answer in any order.`,
        examples: [
          {
            input: 'nums = [2,7,11,15], target = 9',
            output: '[0,1]',
            explanation: 'Because nums[0] + nums[1] == 9, we return [0, 1].'
          },
          {
            input: 'nums = [3,2,4], target = 6',
            output: '[1,2]'
          }
        ]
      },
      'add-two-numbers': {
        title: 'Add Two Numbers',
        difficulty: 'Medium',
        description: `You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.

You may assume the two numbers do not contain any leading zero, except the number 0 itself.`,
        examples: [
          {
            input: 'l1 = [2,4,3], l2 = [5,6,4]',
            output: '[7,0,8]',
            explanation: '342 + 465 = 807.'
          }
        ]
      },
      'median-of-two-sorted-arrays': {
        title: 'Median of Two Sorted Arrays',
        difficulty: 'Hard',
        description: `Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two arrays.

The overall run time complexity should be O(log (m+n)).`,
        examples: [
          {
            input: 'nums1 = [1,3], nums2 = [2]',
            output: '2.00000',
            explanation: 'merged array = [1,2,3] and median is 2.'
          },
          {
            input: 'nums1 = [1,2], nums2 = [3,4]',
            output: '2.50000',
            explanation: 'merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.'
          }
        ]
      }
    }
    
    // If the specific problem is not in our mock data, create a generic problem based on the slug
    if (mockProblems[slug]) {
      return mockProblems[slug]
    } else {
      // Generate a generic problem description based on the slug
      const title = slug.split('-').map(word => 
        word.charAt(0).toUpperCase() + word.slice(1)
      ).join(' ')
      
      return {
        title: title,
        difficulty: 'Medium',
        description: `This is the "${title}" problem from LeetCode. Please analyze the problem based on the title and provide an optimal solution.`,
        examples: [
          {
            input: 'Example input will be provided based on problem analysis',
            output: 'Expected output format',
            explanation: 'Solution explanation will be generated by AI'
          }
        ]
      }
    }
  } catch (error) {
    throw new Error('Failed to fetch problem details')
  }
}

async function solveProblem(problem: LeetCodeProblem) {
  const prompt = `
You are an expert competitive programmer. Analyze this LeetCode problem and provide an optimized solution.

Problem: ${problem.title}
Difficulty: ${problem.difficulty}
Description: ${problem.description}

Examples:
${problem.examples.map((ex, i) => `Example ${i + 1}:
Input: ${ex.input}
Output: ${ex.output}
${ex.explanation ? `Explanation: ${ex.explanation}` : ''}`).join('\n\n')}

Please provide:
1. An optimized solution in Python
2. Time and space complexity analysis
3. Step-by-step explanation of the approach
4. Alternative approaches if applicable

Format your response as JSON with this structure:
{
  "solution": {
    "code": "python code here",
    "language": "Python",
    "timeComplexity": "O(...)",
    "spaceComplexity": "O(...)",
    "explanation": "detailed explanation"
  },
  "alternativeSolutions": [
    {
      "code": "alternative code",
      "approach": "approach name",
      "complexity": "time/space complexity"
    }
  ]
}
`

  const response = await openai.chat.completions.create({
    model: 'llama-3.3-70b-versatile',
    messages: [
      {
        role: 'system',
        content: 'You are an expert competitive programmer who provides clear, optimized solutions with detailed explanations.'
      },
      {
        role: 'user',
        content: prompt
      }
    ],
    temperature: 0.1,
    max_tokens: 2000
  })

  const content = response.choices[0]?.message?.content
  if (!content) {
    throw new Error('No solution generated')
  }

  try {
    return JSON.parse(content)
  } catch (error) {
    // If JSON parsing fails, create a structured response
    return {
      solution: {
        code: content,
        language: 'Python',
        timeComplexity: 'O(n)',
        spaceComplexity: 'O(1)',
        explanation: 'Solution provided by AI'
      },
      alternativeSolutions: []
    }
  }
}

export async function POST(request: NextRequest) {
  try {
    const { url } = await request.json()

    if (!url || typeof url !== 'string') {
      return NextResponse.json(
        { error: 'Valid LeetCode URL is required' },
        { status: 400 }
      )
    }

    // Validate LeetCode URL
    if (!url.includes('leetcode.com/problems/')) {
      return NextResponse.json(
        { error: 'Please provide a valid LeetCode problem URL' },
        { status: 400 }
      )
    }

    // Scrape problem details
    const problem = await scrapeLeetCodeProblem(url)
    
    // Generate solution
    const aiResponse = await solveProblem(problem)

    const result = {
      problem,
      ...aiResponse
    }

    return NextResponse.json(result)

  } catch (error) {
    console.error('Coding agent error:', error)
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Internal server error' },
      { status: 500 }
    )
  }
}